<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Ares: Helpers::Alex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="class_helpers.html">Helpers</a>      </li>
      <li><a class="el" href="class_helpers_1_1_alex.html">Helpers::Alex</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>Helpers::Alex Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Helpers::Alex" -->
<p><code>#include &lt;Utilities/Helpers.Alex.h&gt;</code></p>

<p><a href="class_helpers_1_1_alex-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_helpers_1_1_alex.html#abcd04535bb1fcd3e68d8de7b8bd22044">getCappedDuration</a> (int CurrentValue, int Duration, int Cap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the new duration a stackable or absolute effect will last.  <a href="#abcd04535bb1fcd3e68d8de7b8bd22044"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static DynamicVectorClass<br class="typebreak"/>
&lt; TechnoClass * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_helpers_1_1_alex.html#a1bf422e766e7704df99f1c27de3fc6ca">getCellSpreadItems</a> (CoordStruct *coords, float spread, bool includeInAir=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a list of all units in range of a cell spread weapon.  <a href="#a1bf422e766e7704df99f1c27de3fc6ca"></a><br/></td></tr>
</table>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abcd04535bb1fcd3e68d8de7b8bd22044"></a><!-- doxytag: member="Helpers::Alex::getCappedDuration" ref="abcd04535bb1fcd3e68d8de7b8bd22044" args="(int CurrentValue, int Duration, int Cap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Helpers::Alex::getCappedDuration </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>CurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Cap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the new duration a stackable or absolute effect will last. </p>
<p>The new frames count is calculated the following way:</p>
<p>If Duration is positive it will inflict damage. If Cap is larger than zero, the maximum amount of frames will be defined by Cap. If the current value already is larger than that, in will not be reduced. If Cap is zero, then the duration can add up infinitely. If Cap is less than zero, duration will be set to Duration, if the current value is not higher already.</p>
<p>If Duration is negative, the effect will be reduced. A negative Cap reduces the current value by Duration. A positive or zero Cap will do the same, but additionally shorten it to Cap if the result would be higher than that. Thus, a Cap of zero removes the current effect altogether.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CurrentValue</em>&nbsp;</td><td>The Technos current remaining time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Duration</em>&nbsp;</td><td>The duration the effect uses. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Cap</em>&nbsp;</td><td>The maximum Duration this effect can cause.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new effect frames count.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>AlexB </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2010-04-27 </dd></dl>

<p><div class="fragment"><pre class="fragment">                                                                                      {
                        <span class="comment">// Usually, the new duration is just added.</span>
                        <span class="keywordtype">int</span> ProposedDuration = CurrentValue + Duration;

                        <span class="keywordflow">if</span> (Duration &gt; 0) {
                                <span class="comment">// Positive damage.</span>
                                <span class="keywordflow">if</span> (Cap &lt; 0) {
                                        <span class="comment">// Do not stack. Use the maximum value.</span>
                                        <span class="keywordflow">return</span> std::max(Duration, CurrentValue);
                                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Cap &gt; 0) {
                                        <span class="comment">// Cap the duration.</span>
                                        <span class="keywordtype">int</span> cappedValue = std::min(ProposedDuration, Cap);
                                        <span class="keywordflow">return</span> std::max(CurrentValue, cappedValue);
                                } <span class="keywordflow">else</span> {
                                        <span class="comment">// There is no cap. Allow the duration to stack up.</span>
                                        <span class="keywordflow">return</span> ProposedDuration;
                                }
                        } <span class="keywordflow">else</span> {
                                <span class="comment">// Negative damage.</span>
                                <span class="keywordflow">return</span> (Cap &lt; 0 ? ProposedDuration : std::min(ProposedDuration, Cap));
                        }
                }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1bf422e766e7704df99f1c27de3fc6ca"></a><!-- doxytag: member="Helpers::Alex::getCellSpreadItems" ref="a1bf422e766e7704df99f1c27de3fc6ca" args="(CoordStruct *coords, float spread, bool includeInAir=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static DynamicVectorClass&lt;TechnoClass*&gt;* Helpers::Alex::getCellSpreadItems </td>
          <td>(</td>
          <td class="paramtype">CoordStruct *&nbsp;</td>
          <td class="paramname"> <em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>spread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>includeInAir</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a list of all units in range of a cell spread weapon. </p>
<p>CellSpread is handled as described in <a href="http://modenc.renegadeprojects.com/CellSpread.">http://modenc.renegadeprojects.com/CellSpread.</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>coords</em>&nbsp;</td><td>The location the projectile detonated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spread</em>&nbsp;</td><td>The range to find items in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>includeInAir</em>&nbsp;</td><td>Include items that are currently InAir.</td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>AlexB </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2010-06-28 </dd></dl>

<p><div class="fragment"><pre class="fragment">                                                                                                                                        {
                        <span class="comment">// set of possibly affected objects. every object can be here only once.</span>
                        std::set&lt;TechnoClass*&gt; *<span class="keyword">set</span> = <span class="keyword">new</span> std::set&lt;TechnoClass*&gt;();

                        <span class="comment">// the quick way. only look at stuff residing on the very cells we are affecting.</span>
                        CellStruct cellCoords = MapClass::Instance-&gt;GetCellAt(coords)-&gt;MapCoords;
                        <span class="keywordtype">int</span> countCells = CellSpread::NumCells((<span class="keywordtype">int</span>)(spread + 0.99));
                        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; countCells; ++i) {
                                CellStruct tmpCell = CellSpread::GetCell(i);
                                tmpCell += cellCoords;
                                CellClass *c = MapClass::Instance-&gt;GetCellAt(&amp;tmpCell);
                                <span class="keywordflow">for</span>(ObjectClass *curObj = c-&gt;GetContent(); curObj; curObj = curObj-&gt;NextObject) {
                                        <span class="keywordflow">if</span>(TechnoClass *Techno = generic_cast&lt;TechnoClass*&gt;(curObj)) {
                                                <span class="keyword">set</span>-&gt;insert(Techno);
                                        }
                                }
                        }

                        <span class="comment">// flying objects are not included normally</span>
                        <span class="keywordflow">if</span>(includeInAir) {
                                <span class="comment">// the not quite so fast way. skip everything not in the air.</span>
                                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;TechnoClass::Array-&gt;Count; ++i) {
                                        TechnoClass *Techno = TechnoClass::Array-&gt;GetItem(i);
                                        <span class="keywordflow">if</span>(Techno-&gt;IsInAir()) {
                                                <span class="comment">// rough estimation</span>
                                                <span class="keywordflow">if</span>(Techno-&gt;Location.DistanceFrom(*coords) &lt;= spread * 256) {
                                                        <span class="keyword">set</span>-&gt;insert(Techno);
                                                }
                                        }
                                }
                        }

                        <span class="comment">// look closer. the final selection. put all affected items in a vector.</span>
                        DynamicVectorClass&lt;TechnoClass*&gt; *ret = <span class="keyword">new</span> DynamicVectorClass&lt;TechnoClass*&gt;();
                        <span class="keywordflow">for</span>(std::set&lt;TechnoClass*&gt;::iterator iterator = set-&gt;begin(); iterator != <span class="keyword">set</span>-&gt;end(); iterator++) {
                                TechnoClass *Techno = *iterator;

                                <span class="comment">// ignore buildings that are not visible, like ambient light posts</span>
                                <span class="keywordflow">if</span>(BuildingTypeClass *BT = specific_cast&lt;BuildingTypeClass*&gt;(Techno-&gt;GetTechnoType())) {
                                        <span class="keywordflow">if</span>(BT-&gt;InvisibleInGame) {
                                                <span class="keywordflow">continue</span>;
                                        }
                                }

                                <span class="comment">// get distance from impact site</span>
                                CoordStruct target;
                                Techno-&gt;GetCoords(&amp;target);
                                <span class="keywordtype">double</span> dist = target.DistanceFrom(*coords);

                                <span class="comment">// reduce the distance for flying aircraft</span>
                                <span class="keywordflow">if</span>((Techno-&gt;WhatAmI() == abs_Aircraft) &amp;&amp; Techno-&gt;IsInAir()) {
                                        dist *= 0.5;
                                }

                                <span class="comment">// this is good</span>
                                <span class="keywordflow">if</span>(dist &lt;= spread * 256) {
                                        ret-&gt;AddItem(Techno);
                                }
                        }

                        <span class="comment">// tidy up</span>
                        <span class="keyword">set</span>-&gt;clear();
                        <span class="keyword">delete</span> <span class="keyword">set</span>;

                        <span class="keywordflow">return</span> ret;
                }
</pre></div></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Utilities/<a class="el" href="_helpers_8_alex_8h.html">Helpers.Alex.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 23 2011 23:29:47 for Ares by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
